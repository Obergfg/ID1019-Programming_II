defmodule Vector do

    def smul({x1, x2, x3}, s) do  
        {x1*s, x2*s, x3*s} 
    end

    def sub({x1, x2, x3}, {y1, y2, y3}) do 
        {x1 - y1, x2 - y2, x3 - y3}
    end

    def add({x1, x2, x3}, {y1, y2, y3}) do 
        {x1 + y1, x2 + y2, x3 + y3}
    end

    def norm({x1, x2, x3}) do  
        :math.sqrt(x1*x1 + x2*x2 + x3*x3)
    end

    def dot({x1, x2, x3}, {y1, y2, y3}) do 
      x1*y1 + x2*y2 + x3*y3
    end  

    def normalize(x) do 
        smul(x, 1/norm(x))
    end

    def project(x, y) do 
        dot(x, normalize(y))
    end
end

defmodule Ray do

  defstruct pos: {0, 0, 0}, dir: {1, 1, 1}

end

defmodule Sphere do

  @color {1.0, 0.4, 0.4}

  defstruct pos: {0, 0, 0}, radius: 2, color: @color

  def color(sphere) do
    sphere.color
  end

end

defprotocol Object do

  def intersect(object, ray)

  def color(object)
end

defimpl Object do

  @black {0, 0, 0}
  @white {1, 1, 1}

 	def intersect(sphere = %Sphere{}, ray = %Ray{}) do
        k = Vector.sub(sphere.pos, ray.pos)
        a = Vector.project(k, ray.dir)
        klength = Vector.norm(k)
        h2 = klength*klength - a*a
       
        inters((sphere.radius*sphere.radius - h2), a)
  end

  def intersect(ray, objects) do
    List.foldl(objects, {:inf, nil}, fn(object, sofar) ->
      {dist, _} = sofar

      case Object.intersect(object, ray) do
        {:ok, d} when d < dist ->
          {d, object}
        _ ->
          sofar
      end
    end)
  end

  defp inters(t2, _)when t2 < 0 do 
    :no
  end
  defp inters(t2, a)do 
    t = :math.sqrt(t2)
    closest((a-t), (a+t))
  end

  defp closest(a , b) when a < 0 and b < 0 do 
    cond do 
      a < b -> {:ok, b}
      true -> {:ok, a}
    end
  end
  defp closest(a, b)when a < 0 and b > 0 do 
    cond do 
      -a >= b -> {:ok, b}
      true -> {:ok, -a}
    end
  end
  defp closest(a, _)do 
    {:ok, a}
  end

  def trace(x, y, camera, objects) do
    ray = Camera.ray(camera, x, y)
    trace(ray, objects)
  end

    def trace(ray, objects) do
      case intersect(ray, objects) do
        {:inf, _} ->
          @black
        {_, object} ->
          Object.color(object)
    end
  end

   def color(sphere) do
    sphere.color
  end
  
end


defmodule Tracer do 

  @color {1.0, 0.4, 0.4}

  defstruct pos: {0, 0, 0}, radius: 2 , color: @color

   def tracer(camera, objects) do
      {w, h} = camera.size
      xs = Enum.to_list(1..w)
      ys = Enum.to_list(1..h)
      for y <- ys, do: for(x <- xs, do: Object.trace(x, y, camera, objects))
  end

end



defmodule Camera do

  defstruct pos: nil, corner: nil, right: nil, down: nil, size: nil

  def normal(size) do
    {width, height} = size
    d = width * 1.2
    h = width / 2
    v = height / 2
    corner = {-h, v, d}
    cr = {1, 0 , 0}
    cd = {0, -1, 0}
    %Camera{pos: {0, 0, 0}, corner: corner, right: cr, down: cd, size: size}
  end

  def ray(camera, x, y) do
    origin = camera.pos   
    x_pos = Vector.smul(camera.right, x)   
    y_pos = Vector.smul(camera.down,  y)    
    pixle = Vector.add(camera.corner, x_pos) |> Vector.add(y_pos)   
    dir = Vector.normalize(pixle)
    %Ray{pos: origin, dir: dir}
  end
end

defmodule World do

  defstruct objects: []

end

defmodule PPM do

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn r ->
      colors = row(r)
      IO.write(fd, colors)
  end)
end

  defp row(row) do
    List.foldr(row, [], fn({r, g, b}, a) ->
      [trunc(r * 255), trunc(g * 255), trunc(b * 255) | a]
    end)
  end

end

defmodule Test do

  def snap do
    camera = Camera.normal({800, 600})

    obj1 = %Sphere{pos: 140, pos: {0, 0, 700}, color: {0.8,0.2,1.0}}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}}

    image = Tracer.tracer(camera, [obj1, obj2, obj3])
    PPM.write("test.ppm", image)
  end

end

Test.snap